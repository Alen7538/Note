1、Brian Kernighan：

​	principle：对于任意整数x，令x=x&(x-1)，该运算将x的二进制表示的最后一个1变成0。对x重复此操作直到x变成0，则操作次数即为x的【一比特数】

2、动态规划--最高有效位

​	principle：对于任意整数i，存在整数j使得j为小于等于i的最大2的整数幂。这样的j称为i的最高有效位（计算方法【x&（x-1）==0】），j的二进制除了最高位为1外，其余都为0.而【i-j】的比特数与i的比特数相差1，因此存在公式bits【i】=bit【i-j】+1.

3、动态规划--最低有效位

​	principle：对于任意整数i，若为偶数则bits【i】=bits【i/2】，若为奇数则bits【i】=bits【i/2】+1.

4、动态规划--最低设置位

​	principle：定义正整数x的最低设置位为x的二进制表示中的最低的1所在位。令y=x&(x-1)，显然0<=y<x，bits【x】=bits【y】+1.也即bits【x】=bits【x&(x-1)】+1.